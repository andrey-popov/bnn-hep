/**
 * \author Andrey Popov
 * 
 * The file defines a class to draw the standard figures containing the discriminator's output for
 * the signal and the background. It is intended to be used with ROOT.
 * 
 * \warning The user must include in his/her script the declation of the abstract base class
 * BinaryDiscriminator (included in the header files automatically generated by bnn-hep) *before*
 * this header.
 */

#ifndef PLOT_DISCRIMINATION_HPP
#define PLOT_DISCRIMINATION_HPP

#include "TrainEventList.hpp"

#include <TH1D.h>
#include <THStack.h>
#include <TFile.h>
#include <TTree.h>
#include <TTreeFormula.h>
#include <TCanvas.h>
#include <TStyle.h>
#include <TGaxis.h>
#include <TLegend.h>

#include <string>
#include <vector>
#include <list>
#include <utility>


typedef std::list<std::string> lstring;


/// Class to produce the discrimination plots
class PlotDiscrimination
{
    public:
        /// Constructor
        PlotDiscrimination(BinaryDiscriminator const &discr_, TrainEventList &trainList_);
        
        /// Destructor
        ~PlotDiscrimination();
    
    public:
        /// Defines the input variables and the weight. TTreeFormula syntax is supported
        void SetVariables(lstring const &varNames_, std::string const &weightName_);
        
        /**
         * \brief Defines the input variables and the weights.
         * 
         * Defines the names of the input variables and weights for the signal and background
         * files. In all cases TTreeFormula syntax is supported.
         */
        void SetVariables(lstring const &varNames_, std::string const &sgnWeightName_,
         std::string const &bkgWeightName_);
        
        /// Defines the names of the files to be read
        void SetFileNames(lstring const &sgnFileNames_, lstring const &bkgFileNames_,
         std::string const &treeName_);
        
        /**
         * \brief Draws the dicrimination plot.
         * 
         * Fills histograms with the discriminator's decision for the signal and the background
         * events in the training and the exam sets. Draws the histograms to build the standard
         * discrimination plot. The figure is given the specified title (which can also include
         * the axes' titles) and is saved under the specified file name in three formats: PNG,
         * PDF, and ROOT script.
         */
        void Process(std::string const &title, std::string const &plotFileName);
    
    private:
        /// Reads the source files and fills the given histograms with the discriminator's output
        void FillHists(lstring const &fileNames, std::string const &weightName, TH1D &trainHist,
         TH1D &examHist);
        
        /// Draws the plots. Saves them with the given title and file name
        void Draw(std::string const &title, std::string const &plotFileName);
    
    private:
        lstring varNames;  ///< Names of the input variables
        std::string sgnWeightName, bkgWeightName;  ///< Names of the variables to weight the events
        lstring sgnFileNames;  ///< Names of the ROOT files for the signal
        lstring bkgFileNames;  ///< Names of the ROOT files for the background
        std::string treeName;  ///< Name of the tree to read from the files
        BinaryDiscriminator const &discr;  ///< An instance of a binary discriminator
        Double_t *inputs;  ///< Buffer to ship the inputs to the discriminator
        TrainEventList &trainList;  ///< Object to separate the training and the exam sets
        unsigned nBins;  ///< Number of bins in the histograms
        std::pair<double, double> range;  ///< Range for the histograms
        TH1D sgnTrainHist;  ///< Discriminator's output for the signal in the training set
        TH1D bkgTrainHist;  ///< Discriminator's output for the background in the training set
        TH1D sgnExamHist;  ///< Discriminator's output for the signal in the exam set
        TH1D bkgExamHist;  ///< Discriminator's output for the background in the exam set
};


PlotDiscrimination::PlotDiscrimination(BinaryDiscriminator const &discr_,
 TrainEventList &trainList_):
    discr(discr_), inputs(NULL), trainList(trainList_),
    nBins(30), range(-0.05, 1.05),
    sgnTrainHist("sgnTrainHist", "sgnTrainHist", nBins, range.first, range.second),
    bkgTrainHist("bkgTrainHist", "bkgTrainHist", nBins, range.first, range.second),
    sgnExamHist("sgnExamHist", "sgnExamHist", nBins, range.first, range.second),
    bkgExamHist("bkgExamHist", "bkgExamHist", nBins, range.first, range.second)
    
{
    // Some common decoration
    //gStyle->SetHistLineWidth(2);
    gStyle->SetOptStat(0);
    gStyle->SetStripDecimals(kFALSE);
    
    // Turn off error bars in x-axis
    gStyle->SetErrorX(0.);
    
    // Will need the uncertainties in the histograms
    sgnTrainHist.Sumw2();
    bkgTrainHist.Sumw2();
    sgnExamHist.Sumw2();
    bkgExamHist.Sumw2();
}


PlotDiscrimination::~PlotDiscrimination()
{
    delete [] inputs;
}


void PlotDiscrimination::SetVariables(lstring const &varNames_, std::string const &weightName_)
{
    varNames = varNames_;
    sgnWeightName = weightName_;
    bkgWeightName = weightName_;
    
    // Allocate the buffer for the inputs
    delete [] inputs;
    inputs = new Double_t[varNames.size()];
}


void PlotDiscrimination::SetVariables(lstring const &varNames_, std::string const &sgnWeightName_,
 std::string const &bkgWeightName_)
{
    varNames = varNames_;
    sgnWeightName = sgnWeightName_;
    bkgWeightName = bkgWeightName_;
    
    // Allocate the buffer for the inputs
    delete [] inputs;
    inputs = new Double_t[varNames.size()];
}


void PlotDiscrimination::SetFileNames(lstring const &sgnFileNames_, lstring const &bkgFileNames_,
 std::string const &treeName_)
{
    sgnFileNames = sgnFileNames_;
    bkgFileNames = bkgFileNames_;
    treeName = treeName_;
}


void PlotDiscrimination::Process(std::string const &title, std::string const &plotFileName)
{
    // Fill the histograms
    FillHists(sgnFileNames, sgnWeightName, sgnTrainHist, sgnExamHist);
    FillHists(bkgFileNames, bkgWeightName, bkgTrainHist, bkgExamHist);
    
    // Draw it
    Draw(title, plotFileName);
}


void PlotDiscrimination::FillHists(lstring const &fileNames, std::string const &weightName,
 TH1D &trainHist, TH1D &examHist)
{
    unsigned const nVars = varNames.size();
    
    
    // Loop over the files
    for (lstring::const_iterator fName = fileNames.begin(); fName != fileNames.end(); ++fName)
    {
        trainList.ReadEventList(*fName);
        
        // Get the tree
        TFile file(fName->c_str());
        TTree *tree = dynamic_cast<TTree *>(file.Get(treeName.c_str()));
        long const nEntries = tree->GetEntries();
        
        
        // Prepare the formulas
        std::vector<TTreeFormula *> formulas;
        formulas.reserve(nVars);
        TTreeFormula weightFormula("weight", weightName.c_str(), tree);
        
        for (lstring::const_iterator vName = varNames.begin(); vName != varNames.end(); ++vName)
            formulas.push_back(new TTreeFormula(vName->c_str(), vName->c_str(), tree));
        
        
        // Calculate a factor to rescale weights. It is needed to account for removal of the
        //training set
        long const nEntriesNonZeroWeight = 0;
        
        for (long ev = 0; ev < nEntries; ++ev)
        {
            tree->LoadTree(ev);
            
            if (weightFormula.EvalInstance() != 0.)
                ++nEntriesNonZeroWeight;
        }
        
        double const examWeightFactor = 1. - double(trainList.GetNEvents()) / nEntriesNonZeroWeight;
        //^ Events in the training set have non-zero weights by construction
        
        
        // Fill histograms with BNN output
        for (long ev = 0; ev < nEntries; ++ev)
        {
            tree->LoadTree(ev);
            
            Double_t const weight = weightFormula.EvalInstance();
            
            if (weight == 0.)
                continue;
            
            
            for (unsigned i = 0; i < nVars; ++i)
                inputs[i] = formulas[i]->EvalInstance();
            
            Double_t const value = discr(inputs);
            
            
            if (trainList.CheckEventExam(ev))
                examHist.Fill(value, weight / examWeightFactor);
            else
                trainHist.Fill(value, weight / (1. - examWeightFactor));
        }
        
        
        // Free the memory
        for (unsigned i = 0; i < nVars; ++i)
            delete formulas[i];
    }
    
    
    // Normalize the histograms
    trainHist.Scale(1. / trainHist.Integral());
    examHist.Scale(1. / examHist.Integral());
}


void PlotDiscrimination::Draw(std::string const &title, std::string const &plotFileName)
{
    // Set the decoration
    sgnExamHist.SetLineColor(kBlue);
    sgnExamHist.SetFillColor(38);
    sgnExamHist.SetFillStyle(1001);
    sgnExamHist.SetLineWidth(2);
    
    sgnTrainHist.SetMarkerColor(kBlue);
    sgnTrainHist.SetMarkerStyle(20);
    sgnTrainHist.SetLineColor(kBlue);
    
    bkgExamHist.SetLineColor(kRed);
    bkgExamHist.SetFillColor(kRed);
    bkgExamHist.SetFillStyle(3354);
    bkgExamHist.SetLineWidth(2);
    
    bkgTrainHist.SetMarkerColor(kRed);
    bkgTrainHist.SetMarkerStyle(24);
    bkgTrainHist.SetLineColor(kRed);
    
    
    // Create the canvas
    TCanvas canvas("canvas", "canvas", 1200, 800);
    canvas.SetGrid();
    
    
    // Draw it all
    THStack histStack("histStack", title.c_str());
    histStack.Add(&sgnExamHist, "hist");
    histStack.Add(&bkgExamHist, "hist");
    histStack.Add(&sgnTrainHist, "pe1");
    histStack.Add(&bkgTrainHist, "pe1");
    histStack.Draw("nostack");
    
    
    // The legend
    TLegend legend(0.56, 0.64, 0.73, 0.82);
    legend.AddEntry(&sgnExamHist, "sgn exam", "f");
    legend.AddEntry(&bkgExamHist, "bkg exam", "f");
    legend.AddEntry(&sgnTrainHist, "sgn train", "p");
    legend.AddEntry(&bkgTrainHist, "bkg train", "p");
    
    legend.SetFillColor(kWhite);
    legend.Draw();
    
    
    // Save to files
    canvas.Print((plotFileName + ".pdf").c_str());
    canvas.Print((plotFileName + ".png").c_str());
    canvas.Print((plotFileName + ".C").c_str());
}


#endif
