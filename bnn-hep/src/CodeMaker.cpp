#include "CodeMaker.hpp"

#include <sstream>
#include <ctime>
#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>


using namespace logger;
using std::ofstream;


CodeMaker::CodeMaker(Logger &log_, Config const &config_, InputProcessor const &inputProcessor_,
 FBMWrapper const &fbm_):
    log(log_), config(config_), inputProcessor(inputProcessor_), fbm(fbm_),
    file(config.GetCPPFileName().c_str())
{
    // Create a header file with an abstract base class
    if (not boost::filesystem::exists("BinaryDiscriminator.hpp"))
    {
        ofstream baseClassFile("BinaryDiscriminator.hpp");
        
        baseClassFile <<
         "#ifndef BINARY_DISCRIMINATOR_ABSTRACT_BASE_EXTERNAL\n" <<
         "#define BINARY_DISCRIMINATOR_ABSTRACT_BASE_EXTERNAL\n\n" <<
         "#include <Rtypes.h>\n\n" <<
         "class BinaryDiscriminator\n" <<
         "{\n" <<
         "\tpublic:\n" <<
         "\t\tvirtual Double_t operator()(Double_t const *) const = 0;\n" <<
         "};\n" <<
         "#endif\n";
        
        baseClassFile.close();
    }
    
    
    // Build the neural networks from the BNN
    nets.reserve(config.GetBNNMCMCIterations() - config.GetBNNMCMCBurnIn());
    
    for (unsigned i = config.GetBNNMCMCBurnIn() + 1; i <= config.GetBNNMCMCIterations(); ++i)
        nets.emplace_back(fbm.ReadNN(i));
    // The NN at index 0 corresponds to the generated one and therefore is never considered even as
    //a part of the burn-in
    
    
    // Get the current time (used in the preamble)
    std::time_t rawtime;
    struct std::tm *timeinfo;
    
    std::time(&rawtime);
    timeinfo = std::localtime(&rawtime);
    
    // Write the preamble
    file << "/*******************************************************************************\n" <<
     " * This file was automatically generated by bnn-hep package\n" <<
     " * http://aapopov.web.cern.ch/aapopov/bnn-hep/\n * \n" <<
     " * " << std::asctime(timeinfo) /* it adds a new line */ << " * \n * \n";
    
    // Write the list of input variables
    file << " * The list of input variables:\n";
    vector<string> const &vars = config.GetVariables();
    
    for (unsigned iVar = 0; iVar < vars.size(); ++iVar)
        file << " *  var #" << iVar << ": " << vars.at(iVar) << '\n';
    
    file << " * \n * From the code below, the user is expected to only use the class BNN.\n";
    
    file << " ******************************************************************************/\n" <<
     "\n\n";
    
    
    // Write the includes
    string includeGuardName = config.GetTaskName();
    boost::to_upper(includeGuardName);
    includeGuardName += "_HPP";
    file << "#ifndef " << includeGuardName << "\n#define " << includeGuardName << "\n\n";
    
    file << "#include <Rtypes.h>\n#include <TMath.h>\n\n";
    file << "#include <algorithm>\n#include <list>\n#include <string>\n\n\n";
    
    
    // Write the binary discriminator abstract base class
    file <<
     "#ifdef USE_INTERNAL_BINARY_DISCRIMINATOR_ABSTRACT_BASE\n" <<
     "#ifndef BINARY_DISCRIMINATOR_ABSTRACT_BASE\n" <<
     "#define BINARY_DISCRIMINATOR_ABSTRACT_BASE\n\n" <<
     "class BinaryDiscriminator\n" <<
     "{\n" <<
     "\tpublic:\n" <<
     "\t\tvirtual Double_t operator()(Double_t const *) const = 0;\n" <<
     "};\n" <<
     "#endif\n\n" <<
     "#else\n" <<
     "#include \"BinaryDiscriminator.hpp\"\n" <<
     "#endif\n\n\n";
    
    
    // Define the namespace
    file << "namespace " << config.GetTaskName() << "{\n\n";
    
    
    // Define global variables to provide auxiliary information to the user
    file <<
     "std::string const taskName(\"" << config.GetTaskName() << "\");\n" <<
     "std::list<std::string> inputVarNames;\n" <<
     "std::list<std::string> sgnFileNames;\n" <<
     "std::list<std::string> bkgFileNames;\n";
    
    file << '\n' <<
     "void Initialize()\n" <<
     "{\n";
    
    for (auto const &var: config.GetVariables())
        file << "\tinputVarNames.push_back(\"" << var << "\");\n";
    
    file << '\n';
    
    for (Config::Sample const &sample: config.GetSamples())
    {
        if (sample.type == 0)
            file << "\tsgnFileNames.push_back(\"" << sample.fileName << "\");\n";
        else
            file << "\tbkgFileNames.push_back(\"" << sample.fileName << "\");\n";
    }
    
    file <<
     "}\n";
    
    
    // Write the classes to handle the transformations of the input variables
    file << '\n';
    unsigned transformIndex = 0;
    std::ostringstream ost;
    
    for (auto const &t: inputProcessor.GetTransformations())
    {
        ost << transformIndex;
        t->WriteCode(file, ost.str());
        ost.str("");
        ++transformIndex;
    }
    
    
    // Write the class to describe a neural network with fixed architecture
    nets.front().WriteClass(file);
    
    // Write the BNN class
    WriteBNNClass();
    
    
    // Close the namespace and the include guard
    file << "}\n\n#endif\n";
    
    // Everything done
    log << info(2) << "The source code to apply the BNN is written in the file \"" <<
     config.GetCPPFileName() << "\"." << eom;
}


CodeMaker::~CodeMaker()
{
    file.close();
}


void CodeMaker::WriteBNNClass()
{
    // Write the short class description
    file <<
     "class BNN: public BinaryDiscriminator\n" <<
     "{" <<
     "\t public:\n" <<
     "\t\tBNN(UInt_t netBegin_ = 0, UInt_t netEnd_ = " << nets.size() << ");\n\t\n" <<
     "\tpublic:\n" <<
     "\t\tvoid SetNetRange(UInt_t netBegin_, UInt_t netEnd_);\n" <<
     "\t\tDouble_t operator()(Double_t const *vars) const;\n" <<
     "\t\tDouble_t operator()(Double_t var0";
    
    for (unsigned iVar = 1; iVar < inputProcessor.GetDim(); ++iVar)
        file << ", Double_t var" << iVar;
     
    file << ") const;\n" <<
     "\t\n\tprivate:\n" <<
     "\t\tDouble_t Apply(Double_t const *vars) const;\n" <<
     "\t\n\tprivate:\n" <<
     "\t\tNN nets[" << nets.size() << "];\n" <<
     "\t\tUInt_t netBegin, netEnd;\n";
    
    // Transformation functors
    unsigned nTrans = inputProcessor.GetTransformations().size();
    
    for (unsigned i = 0; i < nTrans; ++i)
        file <<
         "\t\tTransform" << i << " trans" << i << ";\n";
    
    file <<
     "};\n\n\n";
    
    
    // Define the constructor
    file <<
     "BNN::BNN(UInt_t netBegin_, UInt_t netEnd_)\n" <<
     "{\n" <<
     "\tSetNetRange(netBegin_, netEnd_);\n\t\n";
    
    std::ostringstream ost;
    
    for (unsigned iNet = 0; iNet < nets.size(); ++iNet)
    {
        ost << iNet;
        nets[iNet].WriteInitialization(file, "\t", string("nets[") + ost.str() + "].", ost.str());
        ost.str("");
    }
    
    file <<
     "}\n\n\n";
    
    
    // Now methods
    file <<
     "void BNN::SetNetRange(UInt_t netBegin_, UInt_t netEnd_)\n" <<
     "{\n" <<
     "\tnetBegin = netBegin_;\n" <<
     "\tnetEnd = std::min(netEnd_, UInt_t(" << nets.size() << "));\n" <<
     "}\n\n\n";
    
    file <<
     "Double_t BNN::operator()(Double_t const *vars) const\n" <<
     "{\n" <<
     "\treturn Apply(vars);\n" <<
     "}\n\n\n";
    
    file <<
     "Double_t BNN::operator()(Double_t var0";
    
    for (unsigned iVar = 1; iVar < inputProcessor.GetDim(); ++iVar)
        file << ", Double_t var" << iVar;
    
    file << ") const\n" <<
     "{\n" <<
     "\tDouble_t vars[" << inputProcessor.GetDim() << "];\n\t\n";
    
    for (unsigned iVar = 0; iVar < inputProcessor.GetDim(); ++iVar)
        file <<
         "\tvars[" << iVar << "] = var" << iVar << ";\n";
    
    file <<
     "\treturn Apply(vars);\n" <<
     "}\n\n\n";
    
    file <<
     "Double_t BNN::Apply(Double_t const *vars) const\n" <<
     "{\n" <<
     "\tDouble_t transVars[" << inputProcessor.GetDim() << "];\n" <<
     "\tstd::copy(vars, vars + " << inputProcessor.GetDim() << ", transVars);\n\t\n";
    
    for (unsigned i = 0; i < nTrans; ++i)
        file <<
         "\ttrans" << i << "(transVars);\n";
    
    file <<
     "\t\n\tDouble_t res = 0.;\n\t\n" <<
     "\tfor (unsigned n = netBegin; n < netEnd; ++n)\n" <<
     "\t\tres += *nets[n].Apply(transVars);\n\t\n" <<
     "\treturn res / (netEnd - netBegin);\n" <<
     "}\n\n\n";
}
